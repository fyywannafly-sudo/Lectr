local function formatRawHttp(method, url, headers, body)
    local host, path = "unknown", "/"
    
    if url:find("://") then
        local afterProtocol = url:split("://")[2]
        if afterProtocol then
            local parts = afterProtocol:split("/")
            host = parts[1]
            if #parts > 1 then
                path = "/" .. table.concat({table.unpack(parts, 2)}, "/")
            end
        end
    end
    
    local raw = string.format("%s %s HTTP/1.1\nHost: %s\n", method, path, host)
    
    if headers then
        for k, v in pairs(headers) do
            raw = raw .. k .. ": " .. tostring(v) .. "\n"
        end
    end
    
    if body then
        raw = raw .. "Content-Length: " .. #tostring(body) .. "\n\n" .. tostring(body)
    end
    
    return raw
end

local function formatResponse(response, responseHeaders, isTooLong)
    if isTooLong then
        return "-- Response too long (" .. #tostring(response) .. " characters)"
    end
    
    local responseStr = tostring(response)
    if responseStr:match("^HTTP/1%.1") and not (responseHeaders and next(responseHeaders)) then
        return responseStr
    end
    
    local raw = "HTTP/1.1 200 OK\n"
    if responseHeaders then
        for k, v in pairs(responseHeaders) do
            raw = raw .. k .. ": " .. tostring(v) .. "\n"
        end
    end
    
    return raw .. "\n" .. responseStr
end

local function create(class, props)
    local obj = Instance.new(class)
    for k, v in pairs(props) do
        if k == "Parent" then continue end
        obj[k] = v
    end
    obj.Parent = props.Parent
    return obj
end

-- GET SCREEN SIZE FOR RESPONSIVE UI
local screenSize = workspace.CurrentCamera.ViewportSize
local isMobile = screenSize.X < 800
local uiScale = isMobile and 0.8 or 1

local gui = create("ScreenGui", {
    Name = "HttpMonitor", 
    Parent = game:GetService("CoreGui"),
    DisplayOrder = 999
})

local main = create("Frame", {
    Size = isMobile and UDim2.new(0.95, 0, 0.85, 0) or UDim2.new(0, 500, 0, 350),
    Position = isMobile and UDim2.new(0.5, 0, 0.5, 0) or UDim2.new(0.5, -250, 0.5, -175),
    BackgroundColor3 = Color3.fromRGB(25, 25, 25),
    BorderSizePixel = 0,
    Parent = gui
})

if isMobile then
    main.AnchorPoint = Vector2.new(0.5, 0.5)
end

local header = create("Frame", {
    Size = UDim2.new(1, 0, 0, 30),
    BackgroundColor3 = Color3.fromRGB(35, 35, 35),
    BorderSizePixel = 0,
    Parent = main
})

local title = create("TextLabel", {
    Size = UDim2.new(1, -120, 1, 0),
    Position = UDim2.new(0, 10, 0, 0),
    BackgroundTransparency = 1,
    TextColor3 = Color3.new(1, 1, 1),
    Font = Enum.Font.GothamBold,
    TextSize = 14,
    TextXAlignment = Enum.TextXAlignment.Left,
    Text = "ðŸ“¡ HTTP Monitor",
    Parent = header
})

local interceptBtn = create("TextButton", {
    Size = UDim2.new(0, 80, 0, 22),
    Position = UDim2.new(1, -148, 0, 4),
    BackgroundColor3 = Color3.fromRGB(60, 60, 60),
    TextColor3 = Color3.new(1, 1, 1),
    Font = Enum.Font.GothamBold,
    TextSize = 12,
    Text = "Intercept: OFF",
    BorderSizePixel = 0,
    Parent = header
})

local clearBtn = create("TextButton", {
    Size = UDim2.new(0, 60, 0, 22),
    Position = UDim2.new(1, -64, 0, 4),
    BackgroundColor3 = Color3.fromRGB(60, 60, 60),
    TextColor3 = Color3.new(1, 1, 1),
    Font = Enum.Font.GothamBold,
    TextSize = 12,
    Text = "Clear",
    BorderSizePixel = 0,
    Parent = header
})

local listScroll = create("ScrollingFrame", {
    Size = UDim2.new(0.4, -15, 1, -70),
    Position = UDim2.new(0, 10, 0, 35),
    BackgroundColor3 = Color3.fromRGB(30, 30, 30),
    ScrollBarThickness = 6,
    BorderSizePixel = 0,
    Parent = main
})

local tabContainer = create("Frame", {
    Size = UDim2.new(0.6, -15, 0, 30),
    Position = UDim2.new(0.4, 5, 0, 35),
    BackgroundColor3 = Color3.fromRGB(30, 30, 30),
    BorderSizePixel = 0,
    Parent = main
})

local requestTab = create("TextButton", {
    Size = UDim2.new(0.5, -2, 1, 0),
    BackgroundColor3 = Color3.fromRGB(50, 50, 50),
    TextColor3 = Color3.new(1, 1, 1),
    Font = Enum.Font.GothamBold,
    TextSize = 12,
    Text = "ðŸ“¤ Request",
    BorderSizePixel = 0,
    Parent = tabContainer
})

local responseTab = create("TextButton", {
    Size = UDim2.new(0.5, -2, 1, 0),
    Position = UDim2.new(0.5, 2, 0, 0),
    BackgroundColor3 = Color3.fromRGB(40, 40, 40),
    TextColor3 = Color3.new(1, 1, 1),
    Font = Enum.Font.GothamBold,
    TextSize = 12,
    Text = "ðŸ“¥ Response",
    BorderSizePixel = 0,
    Parent = tabContainer
})

local detailScroll = create("ScrollingFrame", {
    Size = UDim2.new(0.6, -15, 1, -110),
    Position = UDim2.new(0.4, 5, 0, 70),
    BackgroundColor3 = Color3.fromRGB(20, 20, 20),
    ScrollBarThickness = 6,
    BorderSizePixel = 0,
    Parent = main
})

local detailText = create("TextBox", {
    Size = UDim2.new(1, -10, 1, 0),
    Position = UDim2.new(0, 5, 0, 0),
    BackgroundTransparency = 1,
    TextColor3 = Color3.new(1, 1, 1),
    Font = Enum.Font.Code,
    TextSize = 12,
    MultiLine = true,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextYAlignment = Enum.TextYAlignment.Top,
    Text = "Select a request to view details",
    ClearTextOnFocus = false,
    TextWrapped = false,
    ClipsDescendants = false,
    Parent = detailScroll
})

-- ACTION BAR WITH DOWNLOAD BUTTON
local actionBar = create("Frame", {
    Size = UDim2.new(0.6, -15, 0, 35),
    Position = UDim2.new(0.4, 5, 1, -40),
    BackgroundColor3 = Color3.fromRGB(30, 30, 30),
    BorderSizePixel = 0,
    Visible = false,
    Parent = main
})

local downloadBtn = create("TextButton", {
    Size = UDim2.new(0, 100, 0, 26),
    Position = UDim2.new(0, 5, 0.5, -13),
    BackgroundColor3 = Color3.fromRGB(80, 80, 150),
    TextColor3 = Color3.new(1, 1, 1),
    Font = Enum.Font.GothamBold,
    TextSize = 12,
    Text = "ðŸ’¾ Download",
    BorderSizePixel = 0,
    Parent = actionBar
})

local forwardBtn = create("TextButton", {
    Size = UDim2.new(0, 100, 0, 26),
    Position = UDim2.new(0.5, -50, 0.5, -13),
    BackgroundColor3 = Color3.fromRGB(80, 150, 80),
    TextColor3 = Color3.new(1, 1, 1),
    Font = Enum.Font.GothamBold,
    TextSize = 12,
    Text = "âœ… Forward",
    BorderSizePixel = 0,
    Parent = actionBar
})

local dropBtn = create("TextButton", {
    Size = UDim2.new(0, 100, 0, 26),
    Position = UDim2.new(1, -105, 0.5, -13),
    BackgroundColor3 = Color3.fromRGB(150, 80, 80),
    TextColor3 = Color3.new(1, 1, 1),
    Font = Enum.Font.GothamBold,
    TextSize = 12,
    Text = "âŒ Drop",
    BorderSizePixel = 0,
    Parent = actionBar
})

local State = {
    requests = {},
    selectedRequest = nil,
    currentTab = "request",
    interceptEnabled = false,
    interceptQueue = {},
    currentIntercept = nil,
    interceptId = 0,
    noLimit = true  -- NO CHARACTER LIMIT!
}

local function updateDetailScroll()
    local lines = string.split(detailText.Text, "\n")
    local maxWidth = 0
    for _, line in ipairs(lines) do 
        maxWidth = math.max(maxWidth, #line) 
    end
    detailScroll.CanvasSize = UDim2.new(0, math.max(maxWidth * 7, detailScroll.AbsoluteSize.X), 0, #lines * 16)
end

local function updateListScroll()
    listScroll.CanvasSize = UDim2.new(0, 0, 0, #State.requests * 42)
end

local function updateDetailView()
    local source = State.selectedRequest and State.requests[State.selectedRequest:GetAttribute("Index")] or State.currentIntercept
    if source then
        if State.currentTab == "request" then
            detailText.Text = source.requestRaw
        else
            detailText.Text = source.responseRaw or "No response data"
        end
        detailText.TextEditable = State.currentIntercept and State.currentTab == "response" and not source.isTooLong
        updateDetailScroll()
    else
        detailText.Text = "Select a request to view details"
        detailText.TextEditable = false
        updateDetailScroll()
    end
end

local function switchTab(tab)
    State.currentTab = tab
    requestTab.BackgroundColor3 = tab == "request" and Color3.fromRGB(50, 50, 50) or Color3.fromRGB(40, 40, 40)
    responseTab.BackgroundColor3 = tab == "response" and Color3.fromRGB(50, 50, 50) or Color3.fromRGB(40, 40, 40)
    updateDetailView()
end

local function createRequestButton(idx, req)
    local bgColor = req.status == "PENDING" and Color3.fromRGB(60, 60, 40) or Color3.fromRGB(40, 40, 40)
    local btn = create("TextButton", {
        Size = UDim2.new(1, -10, 0, 38),
        Position = UDim2.new(0, 5, 0, (idx - 1) * 42),
        BackgroundColor3 = bgColor,
        BorderSizePixel = 0,
        Text = "",
        Parent = listScroll
    })
    btn:SetAttribute("Index", idx)
    
    local statusText = req.status and req.status ~= "PENDING" and " [" .. req.status .. "]" or ""
    local displayUrl = #req.url > 25 and req.url:sub(1, 22) .. "..." or req.url
    
    create("TextLabel", {
        Size = UDim2.new(0, 40, 0, 16),
        Position = UDim2.new(0, 5, 0, 3),
        BackgroundTransparency = 1,
        TextColor3 = req.method == "GET" and Color3.fromRGB(100, 200, 255) 
                    or req.method == "POST" and Color3.fromRGB(255, 200, 100)
                    or Color3.fromRGB(200, 100, 200),
        Font = Enum.Font.GothamBold,
        TextSize = 10,
        Text = req.method,
        TextXAlignment = Enum.TextXAlignment.Left,
        Parent = btn
    })
    
    create("TextLabel", {
        Size = UDim2.new(1, -50, 0, 18),
        Position = UDim2.new(0, 5, 0, 20),
        BackgroundTransparency = 1,
        TextColor3 = Color3.fromRGB(200, 200, 200),
        Font = Enum.Font.Code,
        TextSize = 9,
        Text = displayUrl .. statusText,
        TextXAlignment = Enum.TextXAlignment.Left,
        TextYAlignment = Enum.TextYAlignment.Top,
        TextWrapped = true,
        ClipsDescendants = true,
        Parent = btn
    })
    
    btn.MouseButton1Click:Connect(function()
        if State.selectedRequest then
            local oldIdx = State.selectedRequest:GetAttribute("Index")
            if oldIdx and State.requests[oldIdx] then
                local oldStatus = State.requests[oldIdx].status
                State.selectedRequest.BackgroundColor3 = oldStatus == "PENDING" and Color3.fromRGB(60, 60, 40) or Color3.fromRGB(40, 40, 40)
            end
        end
        
        btn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        State.selectedRequest = btn
        
        if req.interceptData and req.interceptData.sessionId == State.interceptId then
            State.currentIntercept = req.interceptData
            actionBar.Visible = true
            downloadBtn.Visible = State.currentTab == "response"
        else
            State.currentIntercept = nil
            actionBar.Visible = false
        end
        
        updateDetailView()
    end)
    
    return btn
end

local function refreshRequestList()
    for _, child in ipairs(listScroll:GetChildren()) do
        if child:IsA("TextButton") then 
            child:Destroy() 
        end
    end
    
    for i, req in ipairs(State.requests) do
        createRequestButton(i, req)
    end
    
    updateListScroll()
end

local function addRequest(method, url, requestRaw, responseRaw, isTooLong, status, interceptData)
    table.insert(State.requests, 1, {
        method = method, 
        url = url, 
        requestRaw = requestRaw, 
        responseRaw = responseRaw, 
        isTooLong = isTooLong or false, 
        status = status, 
        interceptData = interceptData
    })
    
    refreshRequestList()
end

-- DOWNLOAD FUNCTION
local function downloadResponse()
    if not State.selectedRequest then return end
    
    local idx = State.selectedRequest:GetAttribute("Index")
    if not idx or not State.requests[idx] then return end
    
    local req = State.requests[idx]
    local content = State.currentTab == "request" and req.requestRaw or (req.responseRaw or "")
    
    if #content == 0 then
        warn("[HTTP Monitor] No content to download")
        return
    end
    
    -- Create download file
    local timestamp = os.date("%Y%m%d_%H%M%S")
    local filename = string.format("http_%s_%s_%s.txt", 
        req.method, 
        req.url:gsub("[^%w]", "_"):sub(1, 20),
        timestamp
    )
    
    if writefile then
        pcall(function()
            writefile(filename, content)
            print(string.format("[HTTP Monitor] Saved to: %s (%d chars)", filename, #content))
        end)
    end
    
    -- Copy to clipboard as fallback
    if setclipboard then
        pcall(setclipboard, content)
        print("[HTTP Monitor] Copied to clipboard!")
    end
end

local function updateRequestStatus(interceptData, status)
    for i, req in ipairs(State.requests) do
        if req.interceptData == interceptData then
            State.requests[i].status = status
            State.requests[i].interceptData = nil
            refreshRequestList()
            break
        end
    end
end

local function clearIntercepts()
    for _, item in ipairs(State.interceptQueue) do
        if item.sessionId == State.interceptId then
            updateRequestStatus(item, "CANCELLED")
            if item.callback then 
                task.spawn(item.callback) 
            end
        end
    end
    State.interceptQueue = {}
    State.currentIntercept = nil
    actionBar.Visible = false
    detailText.TextEditable = false
end

local function processNextIntercept()
    while #State.interceptQueue > 0 do
        local nextItem = State.interceptQueue[1]
        if nextItem.sessionId == State.interceptId then
            State.currentIntercept = nextItem
            detailText.Text = State.currentIntercept.responseRaw
            detailText.TextEditable = not State.currentIntercept.isTooLong
            actionBar.Visible = true
            downloadBtn.Visible = State.currentTab == "response"
            switchTab("response")
            updateDetailScroll()
            return
        else
            table.remove(State.interceptQueue, 1)
            updateRequestStatus(nextItem, "CANCELLED")
            if nextItem.callback then 
                task.spawn(nextItem.callback) 
            end
        end
    end
    
    State.currentIntercept = nil
    actionBar.Visible = false
    detailText.TextEditable = false
    updateDetailView()
end

-- CONNECT EVENTS
requestTab.MouseButton1Click:Connect(function() 
    switchTab("request") 
    downloadBtn.Visible = false
end)

responseTab.MouseButton1Click:Connect(function() 
    switchTab("response") 
    downloadBtn.Visible = State.selectedRequest ~= nil
end)

downloadBtn.MouseButton1Click:Connect(function()
    downloadResponse()
end)

clearBtn.MouseButton1Click:Connect(function()
    if #State.interceptQueue > 0 then
        clearIntercepts()
    end
    
    State.requests = {}
    State.selectedRequest = nil
    
    for _, child in ipairs(listScroll:GetChildren()) do
        if child:IsA("TextButton") then 
            child:Destroy() 
        end
    end
    
    detailText.Text = "Select a request to view details"
    actionBar.Visible = false
    updateListScroll()
    updateDetailScroll()
end)

interceptBtn.MouseButton1Click:Connect(function()
    State.interceptEnabled = not State.interceptEnabled
    interceptBtn.Text = State.interceptEnabled and "Intercept: ON ðŸ”´" or "Intercept: OFF"
    interceptBtn.BackgroundColor3 = State.interceptEnabled and Color3.fromRGB(80, 150, 80) or Color3.fromRGB(60, 60, 60)
    
    if State.interceptEnabled then
        State.interceptId = State.interceptId + 1
    else
        clearIntercepts()
    end
end)

forwardBtn.MouseButton1Click:Connect(function()
    if not State.currentIntercept or State.currentIntercept.sessionId ~= State.interceptId then 
        return 
    end
    
    local wasModified = false
    if State.currentTab == "response" and not State.currentIntercept.isTooLong then
        local bodyStart = detailText.Text:find("\n\n")
        local newResponse = bodyStart and detailText.Text:sub(bodyStart + 2) or detailText.Text
        if newResponse ~= tostring(State.currentIntercept.originalResponse) then
            State.currentIntercept.modifiedResponse = newResponse
            wasModified = true
        end
    end
    
    updateRequestStatus(State.currentIntercept, wasModified and "MODIFIED" or nil)
    
    if State.currentIntercept.callback then 
        task.spawn(State.currentIntercept.callback) 
    end
    
    table.remove(State.interceptQueue, 1)
    processNextIntercept()
end)

dropBtn.MouseButton1Click:Connect(function()
    if not State.currentIntercept or State.currentIntercept.sessionId ~= State.interceptId then 
        return 
    end
    
    State.currentIntercept.dropped = true
    updateRequestStatus(State.currentIntercept, "DROPPED")
    
    if State.currentIntercept.callback then 
        task.spawn(State.currentIntercept.callback) 
    end
    
    table.remove(State.interceptQueue, 1)
    processNextIntercept()
end)

local function interceptResponse(method, url, requestRaw, response, responseHeaders, currentSessionId)
    if not State.interceptEnabled or currentSessionId ~= State.interceptId then
        local responseLength = #tostring(response)
        local isTooLong = responseLength > 1000000 and not State.noLimit  -- 1MB limit if noLimit = false
        local responseRaw = formatResponse(response, responseHeaders, isTooLong)
        addRequest(method, url, requestRaw, responseRaw, isTooLong, "CANCELLED")
        return nil
    end
    
    local responseLength = #tostring(response)
    local isTooLong = responseLength > 1000000 and not State.noLimit
    local responseRaw = formatResponse(response, responseHeaders, isTooLong)
    
    local interceptData = {
        method = method, 
        url = url, 
        requestRaw = requestRaw, 
        responseRaw = responseRaw,
        originalResponse = response, 
        modifiedResponse = nil, 
        dropped = false, 
        callback = nil, 
        isTooLong = isTooLong,
        sessionId = currentSessionId
    }
    
    addRequest(method, url, requestRaw, responseRaw, isTooLong, "PENDING", interceptData)
    table.insert(State.interceptQueue, interceptData)
    
    if #State.interceptQueue == 1 then
        State.currentIntercept = interceptData
        State.selectedRequest = nil
        actionBar.Visible = true
        downloadBtn.Visible = true
        switchTab("response")
    end
    
    local thread = coroutine.running()
    interceptData.callback = function() 
        coroutine.resume(thread) 
    end
    coroutine.yield()
    
    return interceptData
end

-- MOBILE FRIENDLY DRAGGING
local UIS = game:GetService("UserInputService")
local dragging, dragStart, startPos

UIS.InputBegan:Connect(function(input, processed)
    if not processed then
        if input.KeyCode == Enum.KeyCode.Home then
            main.Visible = not main.Visible
        elseif input.UserInputType == Enum.UserInputType.Touch then
            local touchPos = input.Position
            local headerAbsPos = header.AbsolutePosition
            local headerAbsSize = header.AbsoluteSize
            
            -- Check if touch is on header (for dragging)
            if touchPos.X >= headerAbsPos.X and touchPos.X <= headerAbsPos.X + headerAbsSize.X
               and touchPos.Y >= headerAbsPos.Y and touchPos.Y <= headerAbsPos.Y + headerAbsSize.Y then
                dragging = true
                dragStart = touchPos
                startPos = main.Position
            end
        elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
            local mousePos = input.Position
            local headerAbsPos = header.AbsolutePosition
            local headerAbsSize = header.AbsoluteSize
            
            if mousePos.X >= headerAbsPos.X and mousePos.X <= headerAbsPos.X + headerAbsSize.X
               and mousePos.Y >= headerAbsPos.Y and mousePos.Y <= headerAbsPos.Y + headerAbsSize.Y then
                dragging = true
                dragStart = mousePos
                startPos = main.Position
            end
        end
    end
end)

UIS.InputChanged:Connect(function(input)
    if dragging then
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement then
            local currentPos = input.Position
            local delta = currentPos - dragStart
            
            -- Mobile: keep UI within screen bounds
            local newX = startPos.X.Offset + delta.X
            local newY = startPos.Y.Offset + delta.Y
            
            if isMobile then
                local screenW = screenSize.X
                local screenH = screenSize.Y
                local uiW = main.AbsoluteSize.X
                local uiH = main.AbsoluteSize.Y
                
                newX = math.clamp(newX, -uiW * 0.1, screenW - uiW * 0.9)
                newY = math.clamp(newY, -uiH * 0.1, screenH - uiH * 0.9)
            end
            
            main.Position = UDim2.new(startPos.X.Scale, newX, startPos.Y.Scale, newY)
        end
    end
end)

UIS.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then 
        dragging = false 
    end
end)

-- Close button for mobile
local closeBtn = create("TextButton", {
    Size = UDim2.new(0, 20, 0, 20),
    Position = UDim2.new(1, -25, 0, 5),
    BackgroundColor3 = Color3.fromRGB(200, 60, 60),
    TextColor3 = Color3.new(1, 1, 1),
    Font = Enum.Font.GothamBold,
    TextSize = 14,
    Text = "X",
    BorderSizePixel = 0,
    Parent = header
})

closeBtn.MouseButton1Click:Connect(function()
    main.Visible = false
end)

-- MINIMIZE BUTTON
local minimizeBtn = create("TextButton", {
    Size = UDim2.new(0, 20, 0, 20),
    Position = UDim2.new(1, -50, 0, 5),
    BackgroundColor3 = Color3.fromRGB(60, 60, 200),
    TextColor3 = Color3.new(1, 1, 1),
    Font = Enum.Font.GothamBold,
    TextSize = 14,
    Text = "_",
    BorderSizePixel = 0,
    Parent = header
})

minimizeBtn.MouseButton1Click:Connect(function()
    if main.Size == UDim2.new(0.95, 0, 0.85, 0) then
        -- Minimize
        main.Size = isMobile and UDim2.new(0.4, 0, 0.1, 0) or UDim2.new(0, 200, 0, 30)
        listScroll.Visible = false
        tabContainer.Visible = false
        detailScroll.Visible = false
        actionBar.Visible = false
    else
        -- Restore
        main.Size = isMobile and UDim2.new(0.95, 0, 0.85, 0) or UDim2.new(0, 500, 0, 350)
        listScroll.Visible = true
        tabContainer.Visible = true
        detailScroll.Visible = true
    end
end)

-- [REST OF THE HOOK FUNCTIONS REMAIN THE SAME AS YOUR ORIGINAL SCRIPT]
-- (HttpService hooks, syn.request hooks, etc. Keep them exactly as you had)

print("ðŸš€ HTTP Monitor v2.0 Loaded!")
print("ðŸ“± Mobile Optimized | ðŸ’¾ Download Feature | ðŸ“œ No Character Limit")
print("ðŸ“Œ Press HOME to show/hide | Drag header to move")
